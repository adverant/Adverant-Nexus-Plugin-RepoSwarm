/**
 * Output Generator for RepoSwarm
 * Generates .arch.md, PDF, HTML, and JSON output formats
 */

import { marked } from 'marked';
import PDFDocument from 'pdfkit';
import {
  AnalysisResult,
  Finding,
  ArchitectureAnalysis,
  ExportFormat,
  ExportOptions,
  TenantContext,
} from '../types';

interface GeneratedOutput {
  format: ExportFormat;
  content: string | Buffer;
  mimeType: string;
  filename: string;
}

export class OutputGenerator {
  private tenantContext?: TenantContext;

  constructor(tenantContext?: TenantContext) {
    this.tenantContext = tenantContext;
  }

  /**
   * Generate output in the specified format
   */
  async generate(
    result: AnalysisResult,
    options: ExportOptions
  ): Promise<GeneratedOutput> {
    const repoName = this.extractRepoName(result.repoUrl);
    const timestamp = new Date().toISOString().split('T')[0];

    switch (options.format) {
      case 'markdown':
        return {
          format: 'markdown',
          content: this.generateMarkdown(result, options),
          mimeType: 'text/markdown',
          filename: `${repoName}.arch.md`,
        };

      case 'json':
        return {
          format: 'json',
          content: this.generateJson(result, options),
          mimeType: 'application/json',
          filename: `${repoName}-analysis-${timestamp}.json`,
        };

      case 'html':
        return {
          format: 'html',
          content: this.generateHtml(result, options),
          mimeType: 'text/html',
          filename: `${repoName}-analysis-${timestamp}.html`,
        };

      case 'pdf':
        return {
          format: 'pdf',
          content: await this.generatePdf(result, options),
          mimeType: 'application/pdf',
          filename: `${repoName}-analysis-${timestamp}.pdf`,
        };

      default:
        throw new Error(`Unsupported format: ${options.format}`);
    }
  }

  /**
   * Generate .arch.md format
   */
  generateMarkdown(result: AnalysisResult, options: ExportOptions): string {
    const sections: string[] = [];

    // Header
    sections.push(this.generateMarkdownHeader(result));

    // Executive Summary
    sections.push(this.generateExecutiveSummary(result));

    // Architecture Overview
    if (options.includeSections?.includes('architecture') ?? true) {
      sections.push(this.generateArchitectureSection(result));
    }

    // Tech Stack
    sections.push(this.generateTechStackSection(result));

    // Security Findings
    if (options.includeSections?.includes('security') ?? true) {
      sections.push(this.generateSecuritySection(result));
    }

    // Performance Analysis
    if (options.includeSections?.includes('performance') ?? true) {
      sections.push(this.generatePerformanceSection(result));
    }

    // Documentation Review
    if (options.includeSections?.includes('documentation') ?? true) {
      sections.push(this.generateDocumentationSection(result));
    }

    // Testing Analysis
    if (options.includeSections?.includes('testing') ?? true) {
      sections.push(this.generateTestingSection(result));
    }

    // Maintainability
    if (options.includeSections?.includes('maintainability') ?? true) {
      sections.push(this.generateMaintainabilitySection(result));
    }

    // Recommendations
    sections.push(this.generateRecommendationsSection(result));

    // Footer
    sections.push(this.generateMarkdownFooter(result));

    return sections.filter((s) => s.length > 0).join('\n\n---\n\n');
  }

  /**
   * Generate markdown header
   */
  private generateMarkdownHeader(result: AnalysisResult): string {
    const repoName = this.extractRepoName(result.repoUrl);
    return `# ${repoName} Architecture Document

> Generated by RepoSwarm AI Analysis
> Date: ${new Date().toISOString()}
> Commit: ${result.commitHash || 'N/A'}
> Branch: ${result.branch}

## Repository Information

| Property | Value |
|----------|-------|
| URL | ${result.repoUrl} |
| Type | ${result.detectedType} |
| Analysis Depth | ${result.analysisDepth} |
| Status | ${result.status} |`;
  }

  /**
   * Generate executive summary
   */
  private generateExecutiveSummary(result: AnalysisResult): string {
    const criticalFindings = result.findings.filter((f) => f.severity === 'critical');
    const highFindings = result.findings.filter((f) => f.severity === 'high');

    let healthStatus = 'Healthy';
    if (criticalFindings.length > 0) {
      healthStatus = 'Critical Issues Found';
    } else if (highFindings.length > 0) {
      healthStatus = 'Attention Needed';
    }

    return `## Executive Summary

**Overall Health:** ${healthStatus}

| Metric | Count |
|--------|-------|
| Critical Issues | ${criticalFindings.length} |
| High Priority Issues | ${highFindings.length} |
| Total Findings | ${result.findings.length} |
| Components Analyzed | ${result.architecture.components.length} |
| Dependencies | ${result.architecture.dependencies.externalDependencies.length} external |

### Key Insights

${result.findings
  .filter((f) => f.severity === 'critical' || f.severity === 'high')
  .slice(0, 5)
  .map((f) => `- **${f.title}** (${f.severity}): ${f.description}`)
  .join('\n')}`;
  }

  /**
   * Generate architecture section
   */
  private generateArchitectureSection(result: AnalysisResult): string {
    const arch = result.architecture;

    const componentsTable = arch.components
      .slice(0, 20)
      .map(
        (c) =>
          `| ${c.name} | ${c.type} | ${c.description || ''} |`
      )
      .join('\n');

    const layersTable = arch.layers
      .map(
        (l) =>
          `| ${l.name} | ${l.type} | ${l.description || ''} |`
      )
      .join('\n');

    return `## Architecture Overview

### Pattern
**${arch.pattern}** (Confidence: ${arch.patternConfidence || 0}%)

${arch.description || 'Architecture pattern detected through static analysis.'}

### Architectural Layers

| Layer | Type | Description |
|-------|------|-------------|
${layersTable}

### Key Components

| Component | Type | Description |
|-----------|------|-------------|
${componentsTable}

### Data Flow

\`\`\`
${this.generateDataFlowDiagram(arch)}
\`\`\``;
  }

  /**
   * Generate data flow diagram as ASCII art
   */
  private generateDataFlowDiagram(arch: ArchitectureAnalysis): string {
    const layers = arch.layers.map((l) => l.name);
    if (layers.length === 0) {
      return 'No layers detected';
    }

    const maxWidth = Math.max(...layers.map((l) => l.length)) + 4;
    const lines: string[] = [];

    layers.forEach((layer, i) => {
      const padding = ' '.repeat(Math.floor((maxWidth - layer.length) / 2));
      lines.push(`+${'-'.repeat(maxWidth)}+`);
      lines.push(`|${padding}${layer}${padding}|`.slice(0, maxWidth + 2));
      if (i < layers.length - 1) {
        lines.push(`+${'-'.repeat(maxWidth)}+`);
        lines.push(`${' '.repeat(maxWidth / 2)}|`);
        lines.push(`${' '.repeat(maxWidth / 2)}v`);
      }
    });
    lines.push(`+${'-'.repeat(maxWidth)}+`);

    return lines.join('\n');
  }

  /**
   * Generate tech stack section
   */
  private generateTechStackSection(result: AnalysisResult): string {
    const stackByCategory = this.categorizeTechStack(result.techStack);

    let content = '## Technology Stack\n\n';

    for (const [category, items] of Object.entries(stackByCategory)) {
      content += `### ${category}\n`;
      content += items.map((item) => `- ${item}`).join('\n');
      content += '\n\n';
    }

    return content;
  }

  /**
   * Categorize tech stack
   */
  private categorizeTechStack(
    techStack: string[]
  ): Record<string, string[]> {
    const categories: Record<string, string[]> = {
      Languages: [],
      Frameworks: [],
      Databases: [],
      Tools: [],
      Other: [],
    };

    const languagePatterns = ['typescript', 'javascript', 'python', 'go', 'rust', 'java', 'ruby', 'php', 'c#'];
    const frameworkPatterns = ['react', 'vue', 'angular', 'express', 'fastapi', 'django', 'rails', 'spring', 'next', 'nest'];
    const dbPatterns = ['postgres', 'mysql', 'mongodb', 'redis', 'elasticsearch', 'neo4j', 'sqlite'];
    const toolPatterns = ['docker', 'kubernetes', 'terraform', 'github', 'gitlab', 'jenkins', 'webpack', 'vite'];

    for (const tech of techStack) {
      const lower = tech.toLowerCase();
      if (languagePatterns.some((p) => lower.includes(p))) {
        categories.Languages.push(tech);
      } else if (frameworkPatterns.some((p) => lower.includes(p))) {
        categories.Frameworks.push(tech);
      } else if (dbPatterns.some((p) => lower.includes(p))) {
        categories.Databases.push(tech);
      } else if (toolPatterns.some((p) => lower.includes(p))) {
        categories.Tools.push(tech);
      } else {
        categories.Other.push(tech);
      }
    }

    // Remove empty categories
    return Object.fromEntries(
      Object.entries(categories).filter(([, items]) => items.length > 0)
    );
  }

  /**
   * Generate security section
   */
  private generateSecuritySection(result: AnalysisResult): string {
    const securityFindings = result.findings.filter(
      (f) => f.findingType === 'security'
    );

    if (securityFindings.length === 0) {
      return `## Security Analysis

No significant security issues found.`;
    }

    const findingsTable = securityFindings
      .map(
        (f) =>
          `| ${f.severity?.toUpperCase() || 'INFO'} | ${f.title} | ${f.location || 'N/A'} |`
      )
      .join('\n');

    return `## Security Analysis

### Findings Summary

| Severity | Finding | Location |
|----------|---------|----------|
${findingsTable}

### Details

${securityFindings
  .map(
    (f) => `#### ${f.title}

- **Severity:** ${f.severity}
- **Location:** ${f.location || 'N/A'}
- **Description:** ${f.description}
- **Recommendation:** ${f.recommendation || 'See details above'}
`
  )
  .join('\n')}`;
  }

  /**
   * Generate performance section
   */
  private generatePerformanceSection(result: AnalysisResult): string {
    const perfFindings = result.findings.filter(
      (f) => f.findingType === 'performance'
    );

    if (perfFindings.length === 0) {
      return `## Performance Analysis

No significant performance issues identified.`;
    }

    return `## Performance Analysis

### Identified Bottlenecks

${perfFindings
  .map(
    (f) => `#### ${f.title}

- **Impact:** ${f.severity}
- **Location:** ${f.location || 'N/A'}
- **Description:** ${f.description}
- **Optimization:** ${f.recommendation || 'See details'}
`
  )
  .join('\n')}`;
  }

  /**
   * Generate documentation section
   */
  private generateDocumentationSection(result: AnalysisResult): string {
    const docFindings = result.findings.filter(
      (f) => f.findingType === 'documentation'
    );

    return `## Documentation Review

### Coverage Assessment

${docFindings.length === 0 ? 'Documentation appears adequate.' : ''}

${docFindings
  .map((f) => `- **${f.title}:** ${f.description}`)
  .join('\n')}`;
  }

  /**
   * Generate testing section
   */
  private generateTestingSection(result: AnalysisResult): string {
    const testFindings = result.findings.filter(
      (f) => f.findingType === 'testing'
    );

    return `## Testing Analysis

### Test Coverage

${testFindings.length === 0 ? 'Testing strategy appears adequate.' : ''}

${testFindings
  .map((f) => `- **${f.title}:** ${f.description}`)
  .join('\n')}`;
  }

  /**
   * Generate maintainability section
   */
  private generateMaintainabilitySection(result: AnalysisResult): string {
    const maintainFindings = result.findings.filter(
      (f) => f.findingType === 'maintainability'
    );

    return `## Maintainability

### Code Quality Assessment

${maintainFindings.length === 0 ? 'Code maintainability is acceptable.' : ''}

${maintainFindings
  .map(
    (f) => `#### ${f.title}

- **Impact:** ${f.severity || 'info'}
- **Description:** ${f.description}
- **Suggestion:** ${f.recommendation || 'N/A'}
`
  )
  .join('\n')}`;
  }

  /**
   * Generate recommendations section
   */
  private generateRecommendationsSection(result: AnalysisResult): string {
    const recommendations = result.findings
      .filter((f) => f.recommendation)
      .map((f) => ({
        priority: this.getSeverityPriority(f.severity),
        text: f.recommendation!,
        category: f.findingType,
      }))
      .sort((a, b) => a.priority - b.priority);

    if (recommendations.length === 0) {
      return `## Recommendations

No critical recommendations at this time.`;
    }

    const prioritized = recommendations.slice(0, 10);

    return `## Recommendations

### Priority Actions

${prioritized
  .map((r, i) => `${i + 1}. **[${r.category}]** ${r.text}`)
  .join('\n')}`;
  }

  /**
   * Get severity priority for sorting
   */
  private getSeverityPriority(severity?: string): number {
    switch (severity) {
      case 'critical':
        return 1;
      case 'high':
        return 2;
      case 'medium':
        return 3;
      case 'low':
        return 4;
      default:
        return 5;
    }
  }

  /**
   * Generate markdown footer
   */
  private generateMarkdownFooter(result: AnalysisResult): string {
    return `## Analysis Metadata

| Property | Value |
|----------|-------|
| Generated | ${new Date().toISOString()} |
| Analysis Duration | ${result.durationMs}ms |
| Tokens Consumed | ${result.tokensConsumed} |
| Agents Used | ${result.agentsUsed} |
| Files Analyzed | ${result.filesAnalyzed} |
| Cache Hit | ${result.cacheHit ? 'Yes' : 'No'} |

---

*Generated by [RepoSwarm](https://adverant.ai/plugins/reposwarm) - AI-Powered Repository Analysis*`;
  }

  /**
   * Generate JSON output
   */
  generateJson(result: AnalysisResult, _options: ExportOptions): string {
    return JSON.stringify(
      {
        version: '1.0',
        generatedAt: new Date().toISOString(),
        analysis: result,
      },
      null,
      2
    );
  }

  /**
   * Generate HTML output
   */
  generateHtml(result: AnalysisResult, options: ExportOptions): string {
    const markdown = this.generateMarkdown(result, options);
    const htmlContent = marked(markdown);
    const repoName = this.extractRepoName(result.repoUrl);

    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${repoName} - Architecture Analysis</title>
    <style>
        :root {
            --bg-color: #0d1117;
            --text-color: #c9d1d9;
            --heading-color: #58a6ff;
            --border-color: #30363d;
            --code-bg: #161b22;
            --table-bg: #161b22;
            --link-color: #58a6ff;
            --critical-color: #f85149;
            --high-color: #db6d28;
            --medium-color: #d29922;
            --low-color: #3fb950;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        h1, h2, h3, h4 {
            color: var(--heading-color);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
        }

        h1 { font-size: 2.5rem; }
        h2 { font-size: 1.75rem; margin-top: 2rem; }
        h3 { font-size: 1.25rem; }

        a {
            color: var(--link-color);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: var(--table-bg);
            margin: 1rem 0;
            border-radius: 6px;
            overflow: hidden;
        }

        th, td {
            padding: 0.75rem 1rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background: rgba(255,255,255,0.05);
            font-weight: 600;
        }

        code {
            background: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9em;
        }

        pre {
            background: var(--code-bg);
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
        }

        pre code {
            background: none;
            padding: 0;
        }

        blockquote {
            border-left: 4px solid var(--heading-color);
            margin: 1rem 0;
            padding: 0.5rem 1rem;
            background: rgba(88, 166, 255, 0.1);
            border-radius: 0 6px 6px 0;
        }

        hr {
            border: none;
            border-top: 1px solid var(--border-color);
            margin: 2rem 0;
        }

        ul, ol {
            padding-left: 1.5rem;
        }

        li {
            margin: 0.5rem 0;
        }

        .severity-critical { color: var(--critical-color); }
        .severity-high { color: var(--high-color); }
        .severity-medium { color: var(--medium-color); }
        .severity-low { color: var(--low-color); }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--heading-color);
        }

        .footer {
            margin-top: 3rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            color: #8b949e;
        }

        @media print {
            body {
                background: white;
                color: black;
            }

            .no-print {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">RepoSwarm Analysis</div>
        <div>Generated: ${new Date().toLocaleDateString()}</div>
    </div>

    ${htmlContent}

    <div class="footer">
        <p>Generated by <a href="https://adverant.ai/plugins/reposwarm">RepoSwarm</a> - AI-Powered Repository Analysis</p>
    </div>
</body>
</html>`;
  }

  /**
   * Generate PDF output
   */
  async generatePdf(
    result: AnalysisResult,
    options: ExportOptions
  ): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      const doc = new PDFDocument({
        size: 'A4',
        margins: { top: 50, bottom: 50, left: 50, right: 50 },
        info: {
          Title: `${this.extractRepoName(result.repoUrl)} - Architecture Analysis`,
          Author: 'RepoSwarm',
          Subject: 'Repository Architecture Analysis',
          Creator: 'RepoSwarm by Adverant',
        },
      });

      const chunks: Buffer[] = [];
      doc.on('data', (chunk) => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);

      // Generate PDF content
      this.writePdfContent(doc, result, options);

      doc.end();
    });
  }

  /**
   * Write PDF content
   */
  private writePdfContent(
    doc: PDFKit.PDFDocument,
    result: AnalysisResult,
    _options: ExportOptions
  ): void {
    const repoName = this.extractRepoName(result.repoUrl);

    // Title page
    doc
      .fontSize(28)
      .fillColor('#58a6ff')
      .text(repoName, { align: 'center' })
      .moveDown();

    doc
      .fontSize(16)
      .fillColor('#666')
      .text('Architecture Analysis Report', { align: 'center' })
      .moveDown(2);

    doc
      .fontSize(12)
      .fillColor('#333')
      .text(`Generated: ${new Date().toLocaleDateString()}`, { align: 'center' })
      .text(`Branch: ${result.branch}`, { align: 'center' })
      .text(`Commit: ${result.commitHash || 'N/A'}`, { align: 'center' });

    doc.addPage();

    // Executive Summary
    doc
      .fontSize(18)
      .fillColor('#58a6ff')
      .text('Executive Summary')
      .moveDown(0.5);

    doc
      .fontSize(11)
      .fillColor('#333')
      .text(`Repository Type: ${result.detectedType}`)
      .text(`Analysis Status: ${result.status}`)
      .text(`Total Findings: ${result.findings.length}`)
      .text(`Critical Issues: ${result.findings.filter((f) => f.severity === 'critical').length}`)
      .moveDown();

    // Architecture Overview
    doc
      .fontSize(18)
      .fillColor('#58a6ff')
      .text('Architecture Overview')
      .moveDown(0.5);

    doc
      .fontSize(11)
      .fillColor('#333')
      .text(`Pattern: ${result.architecture.pattern}`)
      .text(`Confidence: ${result.architecture.patternConfidence || 0}%`)
      .moveDown(0.5)
      .text(result.architecture.description || 'Architecture pattern detected through static analysis.')
      .moveDown();

    // Tech Stack
    doc
      .fontSize(18)
      .fillColor('#58a6ff')
      .text('Technology Stack')
      .moveDown(0.5);

    doc
      .fontSize(11)
      .fillColor('#333')
      .text(result.techStack.join(', '))
      .moveDown();

    // Key Findings
    if (result.findings.length > 0) {
      doc.addPage();

      doc
        .fontSize(18)
        .fillColor('#58a6ff')
        .text('Key Findings')
        .moveDown(0.5);

      for (const finding of result.findings.slice(0, 15)) {
        const severityColor = this.getSeverityColor(finding.severity);

        doc
          .fontSize(12)
          .fillColor(severityColor)
          .text(`[${(finding.severity || 'info').toUpperCase()}] ${finding.title}`)
          .fontSize(10)
          .fillColor('#333')
          .text(finding.description)
          .moveDown(0.5);
      }
    }

    // Footer on each page
    const pages = doc.bufferedPageRange();
    for (let i = 0; i < pages.count; i++) {
      doc.switchToPage(i);
      doc
        .fontSize(8)
        .fillColor('#999')
        .text(
          `Generated by RepoSwarm - Page ${i + 1} of ${pages.count}`,
          50,
          doc.page.height - 30,
          { align: 'center' }
        );
    }
  }

  /**
   * Get color for severity level
   */
  private getSeverityColor(severity?: string): string {
    switch (severity) {
      case 'critical':
        return '#f85149';
      case 'high':
        return '#db6d28';
      case 'medium':
        return '#d29922';
      case 'low':
        return '#3fb950';
      default:
        return '#333';
    }
  }

  /**
   * Extract repository name from URL
   */
  private extractRepoName(repoUrl: string): string {
    const match = repoUrl.match(/\/([^\/]+?)(?:\.git)?$/);
    return match ? match[1] : 'repository';
  }

  /**
   * Set tenant context
   */
  setTenantContext(context: TenantContext): void {
    this.tenantContext = context;
  }
}

export default OutputGenerator;
